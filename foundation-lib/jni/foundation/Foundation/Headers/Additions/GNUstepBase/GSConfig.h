/* Machine/OS specific configuration information for GNUstep

   Please NOTE - GSConfig.h is generated by the configure script from the
   file GSConfig.h.in - changes/fixes need to be made to the original file,
   not to the GSConfig.h generated from it.

   Copyright (C) 1998-2010 Free Software Foundation, Inc.

   Written by:  Richard frith-Macdonald <richard@brainstorm.co.uk>

   This file is part of the GNUstep Base Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02111 USA.
   */

#ifndef	included_GSConfig_h
#define	included_GSConfig_h

#if !defined(NeXT_Foundation_LIBRARY)

/* An alternate to GS_FAKE_MAIN which forces the user to call the 
   NSProcessInfo initialization in 'main', GS_FAKE_MAIN must also
   be undefined. */
#if 0
#define GS_PASS_ARGUMENTS 0
#endif

#define GS_FAKE_MAIN	0 // dont burn in Computer Hell...
#if	GS_FAKE_MAIN

/*
 * NOTE - if GS_FAKE_MAIN (above) is set to 1, this hack applies - and you
 * must make sure that this file is included in any file that implements
 * the 'main()' function and links with the GNUstep base libarary.
 * You should NOT include this file in a program that does not link with
 * the base library.
 * This file is included automatically in NSObject.h and Foundation.h
 *
 * The Foundation classe NSProcessInfo need access to the argc, argv,
 * and env variables of the main() function. The purpose of this (ugly hack)
 * definition is to give the gstep-base library the opportunity to implement
 * its own main function with private access to the global vars. The private
 * main() implementation (in NSProcessInfo.m) will then call the user defined
 * gnustep_base_user_main() function.
 *
 * The original hack was -
 ** Written by:  Georg Tuparev, EMBL & Academia Naturalis,
 **              Heidelberg, Germany
 **              Tuparev@EMBL-Heidelberg.de
 **
 **  NOTE! This is very dirty and dangerous trick. I spend several hours
 ** on thinking and man pages browsing, but couldn't find better solution.
 ** I know that I will spend 666 years in the Computer Hell for writing
 ** this hack, and the master devil (Bully Boy) will send me to write
 ** Windowz software.
 ** BTW, for writing this hack I got personal congratulations from Dennis
 ** Ritchie and Bjarne Stroustrup sent me a bunch of flowers and asked me
 ** to participate in the standardization committee for C-- v.6.0 as
 ** responsible for the new Tab-Overriding-Operator and Scope-Sensitive-
 ** Comments ... but this makes my situation even worse ;-)
 ** - Georg
 *
 * On some systems, there are other relatively clean workarounds, if this
 * applies to the system you are running on, your configuration script
 * should have set GS_FAKE_MAIN to zero, so that this define hack will
 * not be used.
 */

#define main gnustep_base_user_main
extern int gnustep_base_user_main (/* int argc, char *argv[] */);

#ifdef __cplusplus
extern "C" {
    int gnustep_base_user_main (int argc, char *argv[]);
}
#endif

#endif	/* GS_FAKE_MAIN */
#endif

/*
 * Definition to specify if your processor stores words with the most
 * significant byte first (like Motorola and SPARC, unlike Intel and VAX).
 */
#define GS_WORDS_BIGENDIAN	0

/*
 *	Size definitions for standard types
 */
#define	GS_SIZEOF_SHORT		2
#define	GS_SIZEOF_INT		4
#define	GS_SIZEOF_LONG		4
#define	GS_SIZEOF_LONG_LONG	8
#define	GS_SIZEOF_FLOAT		4
#define	GS_SIZEOF_DOUBLE	8
#define	GS_SIZEOF_VOIDP		4

/*
 *	Size information to be places in bits 5 and 6 of type encoding bytes
 *	in archives (bits 0 to 4 are used for basic type info and bit 7 is
 *	used to mark cross-references to previously encoded objects).
 */
#define	_GSC_S_SHT	_GSC_I16
#define	_GSC_S_INT	_GSC_I32
#define	_GSC_S_LNG	_GSC_I32
#define	_GSC_S_LNG_LNG	_GSC_I64

/*
 * Type definitions for types with known sizes.
 */
typedef signed char gss8;
typedef unsigned char gsu8;
typedef signed short gss16;
typedef unsigned short gsu16;
typedef signed int gss32;
typedef unsigned int gsu32;
typedef signed long long gss64;
typedef unsigned long long gsu64;
typedef struct { gsu8 a[16]; } gss128;
typedef struct { gsu8 a[16]; } gsu128;
typedef float gsf32;
typedef double gsf64;

/*
 * Integer type with same size as a pointer
 */
typedef	unsigned int gsuaddr;
typedef	int gssaddr;
typedef	gsuaddr gsaddr;

/*
 *	Do we have real 64-bit and 128-bit integers or are we just pretending.
 */
#define GS_HAVE_I64	1
#define GS_HAVE_I128	0

/*
 *	Do we have zlib for file handle compression?
 */
#define USE_ZLIB	1

/*
 *	Do we have the GNU Multiple-precision library for NSDecimal?
 */
//#define USE_GMP	0
#define USE_GMP	0

/*
 * Macros to deal with hiding an object from the garbage collector
 * This macro employs the procesor-dependent knowledge that a pointer to an
 * object will always be on an even address boundary.  If we ever port to a
 * system where this is not the case, we will have to find another mechanism.
 */
#ifndef	GS_WITH_GC
#define	GS_WITH_GC	0
#endif
#if	GS_WITH_GC
#define	GS_GC_HIDE(obj)		((id)(((uintptr_t)obj) | 1))
#define	GS_GC_UNHIDE(obj)	((id)(((uintptr_t)obj) & ~1))
#else
#define	GS_GC_HIDE(obj)		((id)obj)
#define	GS_GC_UNHIDE(obj)	((id)obj)
#endif

/*
 * Define to say if we use NXConstantString or NSConstantString
 */
#define NXConstantString	NSConstantString

/*
 * Ensure some standard types are defined.
 */
#include <stdint.h>











/*
 * Wide unicode character type.
 */
#ifndef	UTF32Char
#define	UTF32Char	uint32_t
#endif

/*
 * Native character type for use in systemcalls etc.
 */
#if	defined(__MINGW__)
#define	GSNativeChar	uint16_t
#else
#define	GSNativeChar	char
#endif

/*
 * Types used to avoid exposing pthread header in NSLock.h
 * NB. These types should *never* be used except to provide enough space
 * in a class layout for the type of data actually used by the pthread
 * implementation of the current platform.
 */
#if defined(VERDE_MAC) || defined(VERDE_WIN)
#ifdef VERDE_WIN
#include <pthreads/pthread.h>
#endif
// We need more space, just use the real pthread size
#define	gs_cond_t	pthread_cond_t
#define	gs_mutex_t	pthread_mutex_t
#else
typedef  struct {
  uint8_t    dummy[48];
} gs_cond_t;
typedef  struct {
  uint8_t    dummy[24];
} gs_mutex_t;
#endif

#define	OBJC2RUNTIME 1
#define BASE_NATIVE_OBJC_EXCEPTIONS     0
#define GS_NONFRAGILE     0
#define GS_MIXEDABI     0

#import <GNUstepBase/preface.h>

#endif	/* included_GSConfig_h */

